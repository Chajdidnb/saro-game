<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberStrike - Ultimate Shooting Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Rajdhani', sans-serif;
            cursor: default;
        }
        
        #gameCanvas {
            display: block;
        }
        
        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a0a2e 50%, #0f0a1a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s, visibility 0.5s;
        }
        
        #startScreen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .gameTitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            font-weight: 900;
            background: linear-gradient(90deg, #00f0ff, #ff00ff, #00f0ff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientText 3s linear infinite;
            text-shadow: 0 0 50px rgba(0, 240, 255, 0.5);
            margin-bottom: 20px;
        }
        
        @keyframes gradientText {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        .subtitle {
            font-size: 24px;
            color: #888;
            margin-bottom: 50px;
            letter-spacing: 10px;
        }
        
        .startBtn {
            padding: 20px 60px;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            background: linear-gradient(135deg, #00f0ff, #0080ff);
            border: none;
            border-radius: 50px;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        .startBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(0, 240, 255, 0.8);
        }

        .playButtonsContainer {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 30px;
            align-items: center;
        }

        .playBtn {
            padding: 15px 50px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff80, #00cc60);
            border: none;
            border-radius: 30px;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 25px rgba(0, 255, 128, 0.5);
            min-width: 250px;
        }

        .playBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 255, 128, 0.8);
        }

        .playBtn.secondary {
            background: linear-gradient(135deg, #ff6600, #ff9900);
            box-shadow: 0 0 25px rgba(255, 102, 0, 0.5);
        }

        .playBtn.secondary:hover {
            box-shadow: 0 0 40px rgba(255, 102, 0, 0.8);
        }

        .playBtn.tertiary {
            background: linear-gradient(135deg, #ff00ff, #cc00cc);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.5);
        }

        .playBtn.tertiary:hover {
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.8);
        }
        
        .startBtn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: rotate(45deg) translateY(-100%); }
            100% { transform: rotate(45deg) translateY(100%); }
        }
        
        .controls {
            position: absolute;
            bottom: 50px;
            color: #666;
            font-size: 16px;
            text-align: center;
        }
        
        .controls span {
            color: #00f0ff;
        }
        
        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Health Bar */
        .healthContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 300px;
        }
        
        .healthLabel {
            color: #fff;
            font-size: 14px;
            margin-bottom: 5px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .healthBar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
            position: relative;
        }
        
        .healthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0040, #00ff80);
            transition: width 0.3s;
            position: relative;
        }
        
        .healthFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
        }
        
        /* Ammo */
        .ammoContainer {
            position: absolute;
            bottom: 30px;
            left: 350px;
            color: #fff;
            font-size: 28px;
            font-weight: 700;
        }
        
        .ammoCount {
            color: #00f0ff;
            font-family: 'Orbitron', sans-serif;
        }
        
        .ammoMax {
            color: #666;
            font-size: 18px;
        }
        
        /* Weapon Name */
        .weaponName {
            position: absolute;
            bottom: 70px;
            left: 350px;
            color: #00f0ff;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Score */
        .scoreContainer {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #fff;
        }
        
        .scoreLabel {
            font-size: 14px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .scoreValue {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(90deg, #ffd700, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Wave */
        .waveContainer {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .waveText {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Kill Count */
        .killsContainer {
            position: absolute;
            top: 30px;
            right: 30px;
            text-align: right;
            color: #fff;
        }
        
        .killsLabel {
            font-size: 14px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .killsValue {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            font-weight: 900;
            color: #ff0040;
            text-shadow: 0 0 20px #ff0040;
        }
        
        /* Combo */
        .comboContainer {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .comboContainer.active {
            opacity: 1;
        }
        
        .comboText {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: comboPulse 0.5s infinite;
        }
        
        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Weapon Selector */
        .weaponSelector {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
        }
        
        .weaponSlot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            transition: all 0.3s;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .weaponSlot.active {
            border-color: #00f0ff;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
            transform: scale(1.1);
        }
        
        .weaponSlot:hover {
            border-color: #00f0ff;
        }
        
        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 200;
        }
        
        .crosshairDot {
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #fff;
        }
        
        .crosshairRing {
            width: 30px;
            height: 30px;
            border: 2px solid #00f0ff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }
        
        .crosshairRing.shooting {
            width: 40px;
            height: 40px;
            border-color: #ff0040;
        }
        
        .crosshairLine {
            position: absolute;
            background: #00f0ff;
        }
        
        .crosshairLine.top { width: 2px; height: 10px; top: -15px; left: 50%; transform: translateX(-50%); }
        .crosshairLine.bottom { width: 2px; height: 10px; bottom: -15px; left: 50%; transform: translateX(-50%); }
        .crosshairLine.left { width: 10px; height: 2px; left: -15px; top: 50%; transform: translateY(-50%); }
        .crosshairLine.right { width: 10px; height: 2px; right: -15px; top: 50%; transform: translateY(-50%); }
        
        /* Kill Feed */
        .killFeed {
            position: absolute;
            top: 120px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .killFeedItem {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
            animation: feedIn 0.3s, feedOut 0.3s 2.7s forwards;
        }
        
        @keyframes feedIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes feedOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .killFeedItem .killer { color: #00f0ff; }
        .killFeedItem .victim { color: #ff0040; }
        
        /* Powerup Indicator */
        .powerupIndicator {
            position: absolute;
            bottom: 120px;
            left: 30px;
            display: flex;
            gap: 10px;
        }
        
        .powerupIcon {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            opacity: 0.5;
            transition: all 0.3s;
        }
        
        .powerupIcon.active {
            opacity: 1;
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            animation: powerupPulse 0.5s infinite;
        }
        
        @keyframes powerupPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Score Popup */
        .scorePopup {
            position: fixed;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 24px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            pointer-events: none;
            z-index: 300;
            animation: scoreFloat 1s forwards;
        }
        
        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        
        /* Screen Effects */
        .screenShake {
            animation: shake 0.1s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 5px); }
            50% { transform: translate(5px, -5px); }
            75% { transform: translate(-5px, -5px); }
        }
        
        .damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 0, 0.3) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .damageOverlay.active {
            opacity: 1;
        }
        
        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }
        
        #gameOverScreen.active {
            opacity: 1;
            visibility: visible;
        }
        
        .gameOverTitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 64px;
            font-weight: 900;
            color: #ff0040;
            text-shadow: 0 0 50px #ff0040;
            margin-bottom: 30px;
        }
        
        .gameOverStats {
            color: #fff;
            font-size: 24px;
            margin-bottom: 20px;
        }
        
        .gameOverStats span {
            color: #00f0ff;
            font-weight: 700;
        }
        
        .newHighScore {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            margin-bottom: 30px;
            animation: pulse 1s infinite;
        }
        
        /* Reload Indicator */
        .reloadIndicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6600;
            font-size: 18px;
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .reloadIndicator.active {
            opacity: 1;
        }
        
        .reloadBar {
            width: 200px;
            height: 5px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .reloadFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <div class="gameTitle">CYBERSTRIKE</div>
        <div class="subtitle">ULTIMATE SHOOTING EXPERIENCE</div>
        <button class="startBtn" onclick="startGame()">START GAME</button>
        <div class="playButtonsContainer">
            <button class="playBtn" onclick="startGame()">QUICK PLAY</button>
            <button class="playBtn secondary" onclick="startGameWithMode('survival')">SURVIVAL MODE</button>
            <button class="playBtn tertiary" onclick="startGameWithMode('arcade')">ARCADE MODE</button>
        </div>
        <div class="controls">
            <span>WASD</span> Move | <span>MOUSE</span> Aim | <span>CLICK</span> Shoot | <span>1-4</span> Weapons | <span>R</span> Reload
        </div>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD -->
    <div id="hud">
        <!-- Health -->
        <div class="healthContainer">
            <div class="healthLabel">Health</div>
            <div class="healthBar">
                <div class="healthFill" id="healthFill"></div>
            </div>
        </div>
        
        <!-- Ammo -->
        <div class="weaponName" id="weaponName">PISTOL</div>
        <div class="ammoContainer">
            <span class="ammoCount" id="ammoCount">15</span>
            <span class="ammoMax">/<span id="ammoMax">15</span></span>
        </div>
        
        <!-- Reload -->
        <div class="reloadIndicator" id="reloadIndicator">
            RELOADING...
            <div class="reloadBar">
                <div class="reloadFill" id="reloadFill"></div>
            </div>
        </div>
        
        <!-- Score -->
        <div class="scoreContainer">
            <div class="scoreLabel">Score</div>
            <div class="scoreValue" id="scoreValue">0</div>
        </div>
        
        <!-- Wave -->
        <div class="waveContainer">
            <div class="waveText" id="waveText">WAVE 1</div>
        </div>
        
        <!-- Kills -->
        <div class="killsContainer">
            <div class="killsLabel">Kills</div>
            <div class="killsValue" id="killsValue">0</div>
        </div>
        
        <!-- Combo -->
        <div class="comboContainer" id="comboContainer">
            <div class="comboText" id="comboText">2X COMBO!</div>
        </div>
        
        <!-- Kill Feed -->
        <div class="killFeed" id="killFeed"></div>
        
        <!-- Powerups -->
        <div class="powerupIndicator">
            <div class="powerupIcon" id="powerupHealth" title="Health Boost">+</div>
            <div class="powerupIcon" id="powerupSpeed" title="Speed Boost">S</div>
            <div class="powerupIcon" id="powerupRapid" title="Rapid Fire">R</div>
            <div class="powerupIcon" id="powerupShield" title="Shield">SH</div>
        </div>
        
        <!-- Weapon Selector -->
        <div class="weaponSelector">
            <div class="weaponSlot active" id="weapon0" onclick="selectWeapon(0)">1</div>
            <div class="weaponSlot" id="weapon1" onclick="selectWeapon(1)">2</div>
            <div class="weaponSlot" id="weapon2" onclick="selectWeapon(2)">3</div>
            <div class="weaponSlot" id="weapon3" onclick="selectWeapon(3)">4</div>
        </div>
    </div>
    
    <!-- Crosshair -->
    <div id="crosshair">
        <div class="crosshairDot"></div>
        <div class="crosshairRing" id="crosshairRing"></div>
        <div class="crosshairLine top"></div>
        <div class="crosshairLine bottom"></div>
        <div class="crosshairLine left"></div>
        <div class="crosshairLine right"></div>
    </div>
    
    <!-- Damage Overlay -->
    <div class="damageOverlay" id="damageOverlay"></div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <div class="gameOverTitle">GAME OVER</div>
        <div class="gameOverStats">Final Score: <span id="finalScore">0</span></div>
        <div class="gameOverStats">Total Kills: <span id="finalKills">0</span></div>
        <div class="gameOverStats">Waves Survived: <span id="finalWave">0</span></div>
        <div class="newHighScore" id="newHighScore" style="display: none;">NEW HIGH SCORE!</div>
        <button class="startBtn" onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const CONFIG = {
            playerSpeed: 0.4,
            sprintMultiplier: 1.8,
            bulletSpeed: 3,
            enemySpawnRadius: 80,
            baseEnemySpeed: 0.08
        };
        
        // Weapons
        const WEAPONS = [
            { name: 'PISTOL', damage: 25, fireRate: 300, ammo: 15, maxAmmo: 15, reloadTime: 1000, spread: 0.01, color: 0x00f0ff },
            { name: 'RIFLE', damage: 15, fireRate: 100, ammo: 30, maxAmmo: 30, reloadTime: 1500, spread: 0.02, color: 0x00ff00 },
            { name: 'SNIPER', damage: 100, fireRate: 800, ammo: 5, maxAmmo: 5, reloadTime: 2000, spread: 0, color: 0xff0000 },
            { name: 'SHOTGUN', damage: 80, fireRate: 600, ammo: 8, maxAmmo: 8, reloadTime: 1800, spread: 0.1, color: 0xffaa00, pellets: 5 }
        ];
        
        // Game State
        let gameState = {
            isPlaying: false,
            score: 0,
            kills: 0,
            wave: 1,
            combo: 0,
            comboTimer: 0,
            health: 100,
            currentWeapon: 0,
            ammo: WEAPONS[0].ammo,
            canShoot: true,
            isReloading: false,
            powerups: {
                health: false,
                speed: false,
                rapid: false,
                shield: false
            },
            highScore: parseInt(localStorage.getItem('cyberstrikeHighScore')) || 0
        };
        
        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);
        scene.fog = new THREE.FogExp2(0x0a0a0f, 0.008);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(50, 100, 50);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        
        // Ground with grid
        const groundGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            roughness: 0.8,
            metalness: 0.2,
            wireframe: false
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid overlay
        const gridHelper = new THREE.GridHelper(200, 100, 0x00f0ff, 0x1a1a3e);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);
        
        // Player
        const playerGroup = new THREE.Group();
        
        const playerBodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
        const playerBodyMat = new THREE.MeshStandardMaterial({
            color: 0x00f0ff,
            emissive: 0x00f0ff,
            emissiveIntensity: 0.3,
            roughness: 0.3,
            metalness: 0.7
        });
        const playerBody = new THREE.Mesh(playerBodyGeo, playerBodyMat);
        playerBody.position.y = 1;
        playerBody.castShadow = true;
        playerGroup.add(playerBody);
        
        // Player glow
        const playerGlow = new THREE.PointLight(0x00f0ff, 1, 15);
        playerGlow.position.y = 1;
        playerGroup.add(playerGlow);
        
        playerGroup.position.set(0, 0, 0);
        scene.add(playerGroup);
        
        // Enemies
        let enemies = [];
        const enemyGeometry = new THREE.OctahedronGeometry(1);
        
        function createEnemy() {
            const colors = [0xff0040, 0xff6600, 0xff00ff, 0x00ff80, 0xffaa00, 0x00ffff];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const enemyMat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                roughness: 0.3,
                metalness: 0.8
            });
            
            const enemy = new THREE.Mesh(enemyGeometry, enemyMat);
            
            // Spawn at random position
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 50;
            enemy.position.set(
                Math.cos(angle) * radius,
                1 + Math.random() * 2,
                Math.sin(angle) * radius
            );
            
            enemy.userData = {
                health: 100,
                speed: CONFIG.baseEnemySpeed + Math.random() * 0.05,
                targetX: enemy.position.x,
                targetZ: enemy.position.z,
                moveTimer: 0,
                color: color
            };
            
            // Enemy glow
            const glow = new THREE.PointLight(color, 0.8, 10);
            enemy.add(glow);
            
            scene.add(enemy);
            enemies.push(enemy);
            
            return enemy;
        }
        
        // Bullets
        let bullets = [];
        const bulletGeo = new THREE.SphereGeometry(0.15);
        
        function createBullet(position, direction, weapon) {
            const bulletMat = new THREE.MeshBasicMaterial({ color: weapon.color });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.position.copy(position);
            
            // Add spread
            const spreadX = (Math.random() - 0.5) * weapon.spread;
            const spreadZ = (Math.random() - 0.5) * weapon.spread;
            direction.x += spreadX;
            direction.z += spreadZ;
            direction.normalize();
            
            bullet.userData = {
                velocity: direction.clone().multiplyScalar(CONFIG.bulletSpeed),
                damage: weapon.damage,
                life: 100,
                color: weapon.color
            };
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // Muzzle flash
            createMuzzleFlash(position.clone().add(direction.clone().multiplyScalar(1)), weapon.color);
        }
        
        // Muzzle flash effect
        function createMuzzleFlash(position, color) {
            const flashGeo = new THREE.SphereGeometry(0.3);
            const flashMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.position.copy(position);
            
            const flashLight = new THREE.PointLight(color, 2, 5);
            flash.add(flashLight);
            
            scene.add(flash);
            
            // Animate and remove
            let scale = 1;
            const animate = () => {
                scale += 0.2;
                flash.scale.set(scale, scale, scale);
                flash.material.opacity -= 0.2;
                if (flash.material.opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(flash);
                }
            };
            animate();
        }
        
        // Particles
        let particles = [];
        
        function createExplosion(position, color, count) {
            count = count || 15;
            for (let i = 0; i < count; i++) {
                const particleGeo = new THREE.SphereGeometry(0.1 + Math.random() * 0.2);
                const particleMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(position);
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ),
                    life: 30 + Math.random() * 20
                };
                
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Powerups
        let powerups = [];
        const powerupGeo = new THREE.OctahedronGeometry(0.5);
        
        const POWERUP_TYPES = [
            { type: 'health', color: 0x00ff80 },
            { type: 'speed', color: 0xffff00 },
            { type: 'rapid', color: 0xff6600 },
            { type: 'shield', color: 0x00ffff }
        ];
        
        function createPowerup() {
            const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
            const mat = new THREE.MeshStandardMaterial({
                color: type.color,
                emissive: type.color,
                emissiveIntensity: 0.8
            });
            const powerup = new THREE.Mesh(powerupGeo, mat);
            
            powerup.position.set(
                (Math.random() - 0.5) * 100,
                1.5,
                (Math.random() - 0.5) * 100
            );
            
            powerup.userData = {
                type: type.type,
                rotateSpeed: 0.05
            };
            
            const glow = new THREE.PointLight(type.color, 1, 8);
            powerup.add(glow);
            
            scene.add(powerup);
            powerups.push(powerup);
        }
        
        // Controls
        const keys = {};
        const mouse = { x: 0, y: 0 };
        
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.key >= '1' && e.key <= '4') {
                selectWeapon(parseInt(e.key) - 1);
            }
            if (e.key.toLowerCase() === 'r') {
                reload();
            }
        });
        
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        
        // Mouse movement
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                mouse.x += e.movementX * 0.002;
                mouse.y += e.movementY * 0.002;
                mouse.x = Math.max(-1, Math.min(1, mouse.x));
                mouse.y = Math.max(-1, Math.min(1, mouse.y));
            } else {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
        });
        
        // Click to enable pointer lock and shoot
        document.addEventListener('click', () => {
            if (!document.pointerLockElement && gameState.isPlaying) {
                document.body.requestPointerLock();
            }
            if (gameState.isPlaying && document.pointerLockElement) {
                shoot();
            }
        });
        
        // Prevent context menu
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Functions
        function startGame(mode) {
            document.getElementById('startScreen').classList.add('hidden');
            
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.kills = 0;
            gameState.wave = 1;
            gameState.combo = 0;
            gameState.health = 100;
            gameState.currentWeapon = 0;
            gameState.ammo = WEAPONS[0].ammo;
            gameState.canShoot = true;
            gameState.isReloading = false;
            
            // Reset powerups
            Object.keys(gameState.powerups).forEach(function(key) {
                gameState.powerups[key] = false;
            });
            
            // Clear existing enemies
            enemies.forEach(function(e) { scene.remove(e); });
            enemies = [];
            
            // Determine enemy count based on mode
            let enemyCount = 10;
            if (mode === 'survival') enemyCount = 15;
            else if (mode === 'arcade') enemyCount = 8;
            
            // Spawn initial enemies
            for (let i = 0; i < enemyCount; i++) {
                createEnemy();
            }
            
            // Spawn initial powerups
            for (let i = 0; i < 3; i++) {
                createPowerup();
            }
            
            updateUI();
            animate();
        }

        function startGameWithMode(mode) {
            startGame(mode);
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.remove('active');
            
            // Clear everything
            enemies.forEach(function(e) { scene.remove(e); });
            enemies = [];
            bullets.forEach(function(b) { scene.remove(b); });
            bullets = [];
            particles.forEach(function(p) { scene.remove(p); });
            particles = [];
            powerups.forEach(function(p) { scene.remove(p); });
            powerups = [];
            
            playerGroup.position.set(0, 0, 0);
            
            startGame();
        }
        
        function gameOver() {
            gameState.isPlaying = false;
            document.exitPointerLock();
            
            // Check high score
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('cyberstrikeHighScore', gameState.highScore);
                document.getElementById('newHighScore').style.display = 'block';
            } else {
                document.getElementById('newHighScore').style.display = 'none';
            }
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalKills').textContent = gameState.kills;
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('gameOverScreen').classList.add('active');
        }
        
        function shoot() {
            if (!gameState.canShoot || gameState.isReloading || gameState.ammo <= 0) return;
            
            const weapon = WEAPONS[gameState.currentWeapon];
            
            // Check for rapid fire powerup
            const fireRate = gameState.powerups.rapid ? weapon.fireRate / 3 : weapon.fireRate;
            
            gameState.canShoot = false;
            setTimeout(() => gameState.canShoot = true, fireRate);
            
            gameState.ammo--;
            
            // Screen shake
            document.body.classList.add('screenShake');
            setTimeout(() => document.body.classList.remove('screenShake'), 100);
            
            // Crosshair animation
            document.getElementById('crosshairRing').classList.add('shooting');
            setTimeout(() => document.getElementById('crosshairRing').classList.remove('shooting'), 100);
            
            // Create bullets (shotgun has pellets)
            const pellets = weapon.pellets || 1;
            for (let i = 0; i < pellets; i++) {
                const direction = new THREE.Vector3(mouse.x, 0.5, -mouse.y).normalize();
                if (direction.length() === 0) direction.set(0, 0, -1);
                
                // Rotate direction slightly for pellets
                if (pellets > 1) {
                    const angle = (i - (pellets - 1) / 2) * 0.2;
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                }
                
                createBullet(
                    playerGroup.position.clone().add(new THREE.Vector3(0, 1.2, 0)),
                    direction,
                    weapon
                );
            }
            
            updateUI();
            
            if (gameState.ammo <= 0) {
                reload();
            }
        }
        
        function reload() {
            if (gameState.isReloading) return;
            
            const weapon = WEAPONS[gameState.currentWeapon];
            gameState.isReloading = true;
            
            const reloadIndicator = document.getElementById('reloadIndicator');
            const reloadFill = document.getElementById('reloadFill');
            reloadIndicator.classList.add('active');
            
            let progress = 0;
            const reloadInterval = setInterval(() => {
                progress += 10;
                reloadFill.style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(reloadInterval);
                    gameState.ammo = weapon.maxAmmo;
                    gameState.isReloading = false;
                    reloadIndicator.classList.remove('active');
                    reloadFill.style.width = '0%';
                    updateUI();
                }
            }, weapon.reloadTime / 10);
        }
        
        function selectWeapon(index) {
            if (index < 0 || index >= WEAPONS.length) return;
            if (gameState.currentWeapon === index) return;
            
            gameState.currentWeapon = index;
            gameState.ammo = WEAPONS[index].ammo;
            gameState.isReloading = false;
            document.getElementById('reloadIndicator').classList.remove('active');
            
            // Update weapon slots UI
            document.querySelectorAll('.weaponSlot').forEach(function(slot, i) {
                slot.classList.toggle('active', i === index);
            });
            
            updateUI();
        }
        
        function updateUI() {
            // Health
            document.getElementById('healthFill').style.width = gameState.health + '%';
            
            // Ammo
            document.getElementById('ammoCount').textContent = gameState.ammo;
            document.getElementById('ammoMax').textContent = WEAPONS[gameState.currentWeapon].maxAmmo;
            document.getElementById('weaponName').textContent = WEAPONS[gameState.currentWeapon].name;
            
            // Score
            document.getElementById('scoreValue').textContent = gameState.score;
            
            // Wave
            document.getElementById('waveText').textContent = 'WAVE ' + gameState.wave;
            
            // Kills
            document.getElementById('killsValue').textContent = gameState.kills;
            
            // Combo
            const comboContainer = document.getElementById('comboContainer');
            const comboText = document.getElementById('comboText');
            if (gameState.combo >= 2) {
                comboContainer.classList.add('active');
                comboText.textContent = gameState.combo + 'X COMBO!';
            } else {
                comboContainer.classList.remove('active');
            }
            
            // Powerups
            Object.keys(gameState.powerups).forEach(function(key) {
                const el = document.getElementById('powerup' + key.charAt(0).toUpperCase() + key.slice(1));
                if (el) el.classList.toggle('active', gameState.powerups[key]);
            });
        }
        
        function addScore(points, x, y) {
            const multiplier = gameState.combo >= 2 ? 1 + (gameState.combo * 0.1) : 1;
            const finalPoints = Math.floor(points * multiplier);
            gameState.score += finalPoints;
            
            // Score popup
            const popup = document.createElement('div');
            popup.className = 'scorePopup';
            popup.textContent = '+' + finalPoints;
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
            
            updateUI();
        }
        
        function addKillFeed(killer, victim) {
            const feed = document.getElementById('killFeed');
            const item = document.createElement('div');
            item.className = 'killFeedItem';
            item.innerHTML = '<span class="killer">' + killer + '</span> eliminated <span class="victim">' + victim + '</span>';
            feed.appendChild(item);
            setTimeout(() => item.remove(), 3000);
        }
        
        // Wave management
        function checkWave() {
            if (enemies.length === 0) {
                gameState.wave++;
                
                // Spawn more enemies based on wave
                const enemyCount = 5 + gameState.wave * 2;
                for (let i = 0; i < enemyCount; i++) {
                    createEnemy();
                }
                
                // Spawn powerup
                if (Math.random() > 0.3) {
                    createPowerup();
                }
                
                // Bonus score for wave completion
                addScore(500, window.innerWidth / 2, window.innerHeight / 2);
                
                updateUI();
            }
        }
        
        // Main game loop
        function animate() {
            if (!gameState.isPlaying) return;
            
            requestAnimationFrame(animate);
            
            const weapon = WEAPONS[gameState.currentWeapon];
            
            // Player movement
            let speed = CONFIG.playerSpeed;
            if (gameState.powerups.speed) speed *= CONFIG.sprintMultiplier;
            if (keys['ShiftLeft'] || keys['ShiftRight']) speed *= CONFIG.sprintMultiplier;
            
            if (keys['KeyW'] || keys['ArrowUp']) playerGroup.position.z -= speed;
            if (keys['KeyS'] || keys['ArrowDown']) playerGroup.position.z += speed;
            if (keys['KeyA'] || keys['ArrowLeft']) playerGroup.position.x -= speed;
            if (keys['KeyD'] || keys['ArrowRight']) playerGroup.position.x += speed;
            
            // Boundary check
            playerGroup.position.x = Math.max(-95, Math.min(95, playerGroup.position.x));
            playerGroup.position.z = Math.max(-95, Math.min(95, playerGroup.position.z));
            
            // Player rotation (face mouse direction)
            playerGroup.rotation.y = Math.atan2(-mouse.x, -mouse.y);
            
            // Animate player glow
            playerGlow.intensity = 1 + Math.sin(Date.now() * 0.005) * 0.3;
            
            // Enemy AI
            enemies.forEach(function(enemy, index) {
                enemy.userData.moveTimer--;
                
                // Move toward player
                const dx = playerGroup.position.x - enemy.position.x;
                const dz = playerGroup.position.z - enemy.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist > 3) {
                    enemy.position.x += (dx / dist) * enemy.userData.speed;
                    enemy.position.z += (dz / dist) * enemy.userData.speed;
                }
                
                // Look at player
                enemy.lookAt(playerGroup.position);
                
                // Rotate animation
                enemy.rotation.y += 0.02;
                enemy.position.y = 1.5 + Math.sin(Date.now() * 0.003 + index) * 0.3;
                
                // Enemy collision with player
                if (dist < 1.5 && !gameState.powerups.shield) {
                    gameState.health -= 0.3;
                    
                    // Damage effect
                    document.getElementById('damageOverlay').classList.add('active');
                    setTimeout(() => document.getElementById('damageOverlay').classList.remove('active'), 100);
                    
                    if (gameState.health <= 0) {
                        gameState.health = 0;
                        gameOver();
                        return;
                    }
                    updateUI();
                }
            });
            
            // Bullet updates
            bullets.forEach(function(bullet, bIndex) {
                bullet.position.add(bullet.userData.velocity);
                bullet.userData.life--;
                
                // Check enemy collisions
                enemies.forEach(function(enemy, eIndex) {
                    if (bullet.position.distanceTo(enemy.position) < 1.5) {
                        // Hit effect
                        createExplosion(bullet.position.clone(), bullet.userData.color);
                        
                        enemy.userData.health -= bullet.userData.damage;
                        
                        // Remove bullet
                        scene.remove(bullet);
                        bullets.splice(bIndex, 1);
                        
                        // Enemy death
                        if (enemy.userData.health <= 0) {
                            createExplosion(enemy.position.clone(), enemy.userData.color, 30);
                            scene.remove(enemy);
                            enemies.splice(eIndex, 1);
                            
                            // Update combo
                            gameState.combo++;
                            gameState.comboTimer = 120;
                            
                            gameState.kills++;
                            addScore(100, window.innerWidth / 2, window.innerHeight / 2 - 50);
                            addKillFeed('YOU', 'Enemy');
                            
                            checkWave();
                        }
                        
                        return;
                    }
                });
                
                // Remove expired bullets
                if (bullet.userData.life <= 0 || 
                    Math.abs(bullet.position.x) > 100 || 
                    Math.abs(bullet.position.z) > 100) {
                    scene.remove(bullet);
                    bullets.splice(bIndex, 1);
                }
            });
            
            // Particle updates
            particles.forEach(function(particle, index) {
                particle.position.add(particle.userData.velocity);
                particle.userData.velocity.y -= 0.02; // gravity
                particle.userData.life--;
                particle.material.opacity = particle.userData.life / 50;
                particle.scale.multiplyScalar(0.95);
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
            
            // Powerup updates
            powerups.forEach(function(powerup, index) {
                powerup.rotation.y += 0.03;
                powerup.rotation.x += 0.02;
                powerup.position.y = 1.5 + Math.sin(Date.now() * 0.003) * 0.3;
                
                // Check player collection
                if (powerup.position.distanceTo(playerGroup.position) < 2) {
                    const type = powerup.userData.type;
                    gameState.powerups[type] = true;
                    
                    // Apply powerup effect
                    if (type === 'health') {
                        gameState.health = Math.min(100, gameState.health + 30);
                    }
                    
                    // Remove powerup after duration
                    setTimeout(() => {
                        gameState.powerups[type] = false;
                        updateUI();
                    }, 10000);
                    
                    // Add score
                    addScore(50, window.innerWidth / 2, window.innerHeight / 2 - 100);
                    
                    scene.remove(powerup);
                    powerups.splice(index, 1);
                    updateUI();
                }
            });
            
            // Combo timer
            if (gameState.comboTimer > 0) {
                gameState.comboTimer--;
            } else {
                gameState.combo = 0;
                updateUI();
            }
            
            // Camera follow
            camera.position.x += (playerGroup.position.x - camera.position.x) * 0.1;
            camera.position.z += (playerGroup.position.z + 20 - camera.position.z) * 0.1;
            camera.position.y = 15;
            camera.lookAt(playerGroup.position);
            
            renderer.render(scene, camera);
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initial render
        renderer.render(scene, camera);
    </script>
</body>
</html>
